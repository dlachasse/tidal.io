User.create!([
  {name: nil, email: "cmoanr@gmail.com", remember_me_token: nil, remember_me_token_expires_at: nil, reset_password_token: nil, reset_password_token_expires_at: nil, reset_password_email_sent_at: nil, activation_state: "pending", activation_token: "W1Ma3xBZHnzr5mTyDMsq", activation_token_expires_at: nil, crypted_password: "$2a$10$WMieZ5XgBvWhvHaF2UODHO5WHtwLOvmLGCZ7xr7DYENjz0y/CMJFK", password_confirmation: nil, salt: "yUq753CYc2zKmDczWnv9", api_key: "KICKsuE4k7pJzzbZay5tNwtt"},
  {name: "test", email: "testing@testing.com", remember_me_token: nil, remember_me_token_expires_at: nil, reset_password_token: nil, reset_password_token_expires_at: nil, reset_password_email_sent_at: nil, activation_state: "pending", activation_token: "zw8Ca7z2LqLNVooqd9t8", activation_token_expires_at: nil, crypted_password: "$2a$10$Jy2UDWDvia350yWITil7RuV6E4hG0ErxXF3PMiJv2nm.Yl4bRLae2", password_confirmation: nil, salt: "knxX9UvrfcmrwPqzFJjn", api_key: "fg0dqeZoI0aZIl54Ne4Qigtt"},
  {name: "David La Chasse", email: "david.lachasse@gmail.com", remember_me_token: nil, remember_me_token_expires_at: nil, reset_password_token: nil, reset_password_token_expires_at: nil, reset_password_email_sent_at: nil, activation_state: "active", activation_token: nil, activation_token_expires_at: nil, crypted_password: "$2a$10$SbHot5E4naM1MD/XgXacUuumT1PwjtRfGtFf47ZPnn6rVaA53663m", password_confirmation: nil, salt: "Ex81ogAAMAtc13X52fsh", api_key: "8edtzueYO7ENV3pzlCrCbgtt"}
])
Feed.create!([
  {name: "Information Architects", url: "http://ia.net", last_checked: "2014-07-02 03:32:35", favicon: "http://ia.net/favicon.ico", feed_url: "http://ia.net/feed/"}
])
Article.create!([
  {title: "USP: fcntl: file descriptor flags vs file status flags", permalink: "http://blog.rubybestpractices.com/posts/ewong/018-fcntl-file-descriptor-flags-vs-file-status-flags.html", body: "<p>The fcntl(2) system call is one several system calls used to get and set internal attributes of file descriptors and open files they point to.</p>\n<p>Ruby exposes the IO#fcntl method and provides some useful constants in the Fcntl module of the standard library.</p>\n<p>fcntl(2) has several uses, but commonly it is used to get/set two types of flags:</p>\n<ul>\n\t<li>file descriptor flags</li>\n\t<li>file status flags</li>\n</ul>\n<p>To a Rubyist, these flags can be thought of as instance variables, with fcntl() providing getter/setter methods for these variables.</p>\n<p>As you may remember<sup class=\"footnote\" id=\"fnr1\"><a href=\"#fn1\">1</a></sup>, IO#dup creates a new file descriptor and a new Ruby IO object, but does not create a new file object within the kernel.  This is an important distinction for understanding this post.</p>\n<p><sup class=\"footnote\" id=\"fnr1\"><a href=\"#fn1\">1</a></sup> &#8211; http://mid.gmane.org/20111019025953.GA10010@dcvr.yhbt.net</p>\n<h2>File descriptor flags (Fcntl::F_GETFD, Fcntl::F_SETFD)</h2>\n<p>File descriptor flags only pertain to one file descriptor (FD) owned by one process.  If an IO object is created with IO#dup, changing the descriptor flags of either the newly-created or original IO object does not affect the other.</p>\n<p>To get the file descriptor flags of a given IO object:</p>\n<pre name=\"code\" class=\"ruby\">\n        # flags is an Integer (used as a bit mask)\n        flags = io.fcntl(Fcntl::F_GETFD)\n</pre>\n<p>To set file descriptor flags of a given IO object:</p>\n<pre name=\"code\" class=\"ruby\">\n        io.fcntl(Fcntl::F_SETFD, flags)\n</pre>\n<p>There is only one standardized file descriptor flag (which will be covered in a separate post).</p>\n<h2>File status flags (Fcntl::F_GETFL, Fcntl::F_SETFL)</h2>\n<p>File status flags share more in common with other file attributes (e.g.  file offsets) than file descriptor flags.  Status flags affect the underlying file object in the kernel (and not just the file descriptor).</p>\n<p>With IO#dup-ed objects (and thus file descriptors), changing the file status flag on one of the IO objects <em>will</em> affect the other one.</p>\n<p>To get the file status flags of a given IO object:</p>\n<pre name=\"code\" class=\"ruby\">\n        # flags is an Integer (used as a bit mask)\n        flags = io.fcntl(Fcntl::F_GETFL)\n</pre>\n<p>To set the file status flags of a given IO object:</p>\n<pre name=\"code\" class=\"ruby\">\n        io.fcntl(Fcntl::F_SETFL, flags)\n</pre>\n<p>Since there may be several processes sharing and using an open file simultaneously, setting file status flags can be a relatively expensive operation in the kernel compared to setting file descriptor flags.</p>\n<p>Examples of file status flags include <em>some</em> of the flags which may be passed to File.open:</p>\n<pre name=\"code\" class=\"ruby\">\n        IO::APPEND, IO::RDWR, IO::RDONLY, IO::WRONLY, IO::NONBLOCK\n</pre>\n(The Fcntl module provides Fcntl::O_* versions of these\nconstants, e.g. Fcntl::O_RDWR)\n<p>Some of these flags may be changed with Fcntl::F_SETFL, while others are read-only and only available for informational purposes.</p>\n<p>License: GPLv3 or later, http://www.gnu.org/licenses/gpl-3.0.txt</p>", published: "2012-09-23 14:43:00", feed_id: 1},
  {title: "USP: Handling excessive CPU Usage within a Process", permalink: "http://blog.rubybestpractices.com/posts/ewong/017-Handling-excessive-CPU-Usage-within-a-Process.html", body: "<p>If you&#8217;ve ever had issues with a runaway process eating up <span class=\"caps\">CPU</span> time and want to kill it automatically, it&#8217;s possible to use Process.{get,set}rlimit and a signal handler for <span class=\"caps\">SIGXCPU</span> to accomplish this.</p>\n<p>The following snippet of code implements an example of a <span class=\"caps\">CPU</span> limiter.  This self-contained example aborts itself once <span class=\"caps\">CPU</span> utilization reaches 50%.</p>\n<pre name=\"code\" class=\"ruby\">\n# Users of older Rubies may want to use Process::RLIMIT_CPU\n# instead of :CPU in this code.\n\nsoft, hard = Process.getrlimit(:CPU)\nlast_update = Time.now\nmax_cpu_time = 5\n\n# this signal handler runs once we've hit max_cpu_time:\ntrap(:XCPU) do\n\n # Calculate CPU utilization based on elapsed (wall clock) time\n # and max_cpu_time\n elapsed = Time.now - last_update\n cpu_usage = max_cpu_time / elapsed\n puts \"CPU utilization: \#{\"%0.2f\" % (cpu_usage * 100)}\"\n if cpu_usage &gt; 0.5 # 50%\n   abort \"CPU utilization exceeded 50%\"\n end\n\n # If we're below our CPU usage threshold, install a new limit based on\n # current Process.times\n last_update = Time.now\n t = Process.times\n Process.setrlimit(:CPU, max_cpu_time + t.utime.round + t.stime.round, hard)\n\n # We now return to our regularly scheduled looping ...\nend\n\n\n# Install an initial limit for max_cpu_time using existing process times\nt = Process.times\nProcess.setrlimit(:CPU, max_cpu_time + t.utime.round + t.stime.round, hard)\n\n# The signal handler registered for :XCPU will run automatically\n# after the CPU time hits max_cpu_time seconds\nloop do\n # do something to use the CPU...\n 100000.times { 1 + 1 }\n\n # you can change the amount of time slept to influence CPU utilization\n sleep 0.01\nend\n</pre>\n<p>I learned this example a few years ago from reading the PulseAudio source code:</p>\n<pre name=\"code\" class=\"shell\">\n       $ git clone git://git.0pointer.de/pulseaudio\n       $ $EDITOR src/daemon/cpulimit.c\n</pre>\n<p>GPLv3 does <em>not</em> cover this message, which is CC0: To the extent possible under law, Eric Wong has waived all copyright and related or neighboring rights to the contents of this message.</p>", published: "2012-03-27 05:11:00", feed_id: 1},
  {title: "USP: Implementing signal handlers - some caveats", permalink: "http://blog.rubybestpractices.com/posts/ewong/016-Implementing-Signal-Handlers.html", body: "<h2>Signal handlers may run at any time</h2>\n<p>If your program receives a signal, Ruby will invoke the associated signal handler as soon as it is able to.  This means a signal handler can hijack your existing code flow just about anywhere in your program (including inside methods of any libraries you use).  Normal code execution resumes once the signal handler finishes execution.</p>\n<p>This is a big difference from most event-driven programming frameworks where callbacks for a given object/event fire synchronously and will not step over existing code flow.</p>\n<h2>Reentrancy vs thread-safety</h2>\n<p>While reentrancy and thread-safety are related concepts, it is absolutely critical to understand is they are <span class=\"caps\">NOT</span> the same, and one does not imply the other.</p>\n<p>(There are existing articles on this, so I won&#8217;t dive into this more.)</p>\n<h2>Signal handlers must be reentrant</h2>\n<p>When writing a signal handler, you must ask yourself:</p>\nWhat happens when another signal arrives while this handler is still running?\n<p>Since signal handlers are invoked as soon as possible, they can even run while another (or the same) signal handler is running.  Thus signal handlers must be able to tolerate reentrancy.</p>\n<p>Back to thread-safety: some constructs required for thread-safety fail horribly when used in situations that require reentrancy.  Most mutex implementations (including the Ruby Mutex class) deadlock when used inside a signal handler.</p>\n<p>Consider the following snippet:</p>\n<pre name=\"code\" class=\"ruby\">\n       lock = Mutex.new\n\n       # XXX this is an example of what NOT to do inside a signal handler:\n       trap(:USR1) do\n         lock.synchronize do\n           # if a second SIGUSR1 arrives here, this block of code\n           # will fire again.   Attempting Mutex#synchronize twice\n           # the same thread leads to a deadlock error\n         end\n       end\n</pre>\n<p>Thus, you must ensure any code you use inside a signal handler is reentrant-safe.  Even using the Logger class in the Ruby standard library (which can call Mutex#synchronize) can deadlock inside a signal handler.</p>\n<h2>Signal reliability</h2>\n<p>Signals are not completely reliable in Ruby (nor many applications, for that matter).  If multiple, identical signals are received in a short time frame, you&#8217;re guaranteed to fire a handler for /at least/ one of the signals, but not all of the signals received.</p>\n<p>This is because Ruby implementations must<sup class=\"footnote\" id=\"fnr1\"><a href=\"#fn1\">1</a></sup> block signals from firing while manipulating internal data structures.  When normal signals get blocked, they do not queue up in the OS kernel and instead only get a boolean bit set.</p>\n<p><sup class=\"footnote\" id=\"fnr1\"><a href=\"#fn1\">1</a></sup> &#8211; back to reentrancy, temporarily blocking signals to ensure reentrant-safe data manipulation is analogous to using a mutex lock to accomplish thread-safe data manipulation.</p>\n<h2>Untrappable, unblockable signals</h2>\n<p>Regardless of the Ruby runtime state, <span class=\"caps\">SIGSTOP</span> still suspend a process immediately (until <span class=\"caps\">SIGCONT</span> is received), and cannot be trapped by the Ruby runtime (or any userspace process).</p>\n<p>Similarly, <span class=\"caps\">SIGKILL</span> terminates a process immediately.  Processes are are given no chance to stop or react to them.  Thus, no blocks registered via Kernel#at_exit, <span class=\"caps\">END</span>, nor object finalizers can run upon <span class=\"caps\">SIGKILL</span>.</p>\n<p>Sending &#8220;Ctrl-Z&#8221; from a terminal generates <span class=\"caps\">SIGTSTP</span>, not <span class=\"caps\">SIGSTOP</span>, and <span class=\"caps\">SIGTSTP</span> is trappable.</p>\n<h2>Deferred signal handling</h2>\n<p><span class=\"caps\">POSIX</span> defines a very small number of C functions that are safe to use inside a signal handler<sup class=\"footnote\" id=\"fnr2\"><a href=\"#fn2\">2</a></sup>.  As Ruby programmers have little direct control over which C functions they end up calling, Ruby implementations (at least modern ones) implement deferred signal handling.</p>\n<p>Thus Ruby implementations register trap signals using C functions (via sigaction(2)) and dispatch Ruby signal handlers out when the VM/interpreter is in a safe state.</p>\n<p>Modern versions of Perl (and presumably other high-level languages) also use deferred signal handling.</p>\n<p>Even with deferred signal handling implemented by the language runtime, it is still a good idea to <em>also</em> implement deferred signal handling in your Ruby applications to avoid the same reentrancy pitfalls.</p>\n<p><sup class=\"footnote\" id=\"fnr2\"><a href=\"#fn2\">2</a></sup> &#8211; Linux signal(7) manpage is one place that lists these functions</p>\n<p>License: GPLv3 or later, http://www.gnu.org/licenses/gpl-3.0.txt</p>", published: "2012-03-27 04:25:00", feed_id: 1}
])
Subscription.create!([
  {user_id: 1, feed_id: 1}
])
